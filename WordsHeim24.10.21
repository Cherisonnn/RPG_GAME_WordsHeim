#include <iostream>
#include<graphics.h>
#include<string>
#include<fstream>
#include<sstream>
#include <vector>
#include <map>
#include<random>
#include <print>
#include <iomanip>
using namespace std;
void SelectMove();
void SelectMove_Wild();
void Shop();
void LoadGame();
void Save();
enum Location {//地点：定义
	克里斯镇, 克里斯镇北郊, 克里斯镇东郊
};
struct LOC {
	Location location;
	Location getLocation() const {
		return location;
	}
	LOC() :location() {}
	void setLocation(Location loc) {
		location = loc;
	}
};
LOC lplayer,safepoint;
std::string locationName(Location loc);
void ShowLocation(LOC& loc);
Location currentLocation;

class Prop_Weapon {//武器
public:
	string NAME;
	int wATK;
	int Durabily;
	int n;
	int cost;
	void setWeapon(string sname, int sa, int sd, int sn, int sc) {
		NAME = sname;
		wATK = sa;
		Durabily = sd;
		n = sn;
		cost = sc;
	}
	void ShowAvailWeapon()const {
		cout << NAME << endl;
	}
}w0001;
void SelectAvailWeapon(const vector<Prop_Weapon>& weapon);
void SetWeapon() {//武器：设置
	w0001.setWeapon("克里斯学徒的试做铜剑", 2, 15, 0, 12);
}
void AvailWeapon(){//武器：可用
	vector<Prop_Weapon> weapon = {
		w0001
	};
	vector<Prop_Weapon> filterWeapon;
	std::copy_if(weapon.begin(), weapon.end(), std::back_inserter(filterWeapon),
		[](const Prop_Weapon& w) { return w.n >= 1; });
	int i = 1;
	for (const auto& weapon : filterWeapon) {
		cout << i++ << ": ";
		weapon.ShowAvailWeapon();
	}
	SelectAvailWeapon(filterWeapon);
}
class player {
public:
	int HP;
	int HPmax;
	int DEF;
	int ATK;
	int Coin;
	int Lev;
	int Exp;
	int ExpMax, LevelUp_n;
	string position;
	Prop_Weapon hold;
	void LevelUp() {
		LevelUp_n = 0;
		while (Exp > ExpMax) {
			Exp = Exp - ExpMax;
			LevelUp_n++;
			ExpMax = 5 + 5 * (Lev + LevelUp_n);
		}
		if (LevelUp_n > 0) {
			cout << "恭喜！您的等级提升了<" << LevelUp_n << ">级！\n" << endl;
		}
		Lev = Lev + LevelUp_n;
		setProperty();
	}
	void InitProperty() {//新的游戏
		Lev = 1;
		ExpMax = 5 + 5 * Lev;
		HPmax = 10 + (Lev - 1) * 2;
		DEF = 0;
		ATK = 2 + (Lev - 1) * 1;
		Coin = 0;
		Exp = 0;
	}
	void SetLevel() {//等级修改器
		cout << "Your Level is:";
		cin >> Lev;
		HPmax = 10+(Lev-1)*2;
		DEF = 0;
		ATK = 2+(Lev-1)*1;
		Coin = 0;
	}
	void setProperty() {//继续游戏，属性由等级赋值
		ATK = 2 + (Lev - 1) * 1;
		HPmax = 10 + (Lev - 1) * 2;
		ExpMax = 5 + 5 * Lev;
	}
	void ShowCoin() {
		int key;
		cout << "您的余额为 " << oplayer.Coin << endl;
		cout << "输入1以返回" << endl;
		cin >> key;
		while (key != 1) {
			cout << "错误输入" << endl;
			cin.clear();
			cin.ignore(1024, '\n');
			cin >> key;
		}
		system("cls");
		SelectMove();
	}
	void GearWeapon(Prop_Weapon w) {
		oplayer.hold = w;
	}
	void ShowGear() {
		int key,gkey;
		cout << "============================" << endl;
		cout << "1:首: " << endl;
		cout << "2:身: " << endl;
		cout << "3:手: " << endl;
		cout << "4:足: " << endl;
		cout << "----------------------------" << endl;
		cout << "5:手持: " << hold.NAME << endl;
		cout << "============================" << endl;
		cout << "6:返回" << endl;
		cin >> key;
		system("cls");
		switch (key) {
		case(1):
		case(2):
		case(3):
		case(4):
		case(5):
			ShowHold();
		case(6):
			SelectMove();
		default:
			cout << "无效输入，请重新选择！" << endl;
			cin.clear();
			cin.ignore(1024, '\n');
			ShowGear();
		}
	}
	void ShowHold() {
		int key;
		int i = 0;
		cout << "0: 返回" << endl;
		cout << "当前装备：" << hold.NAME << endl;
		cout << "可装备：" << endl;
		AvailWeapon();
	}
	void ShowProperty() {
		int key;
		cout << "您的等级为<" << oplayer.Lev <<">" << endl;
		cout << "HP:" << oplayer.HP << "/"<<oplayer.HPmax<<endl;
		cout << "DEF:" << oplayer.DEF << endl;
		cout << "ATK:" << oplayer.ATK <<" + "<<oplayer.hold.wATK<< endl;
		cout << "Exp:" << oplayer.Exp << "/" << oplayer.ExpMax << endl;
		cout << "输入1以返回" << endl;
		cin >> key;
		while (key != 1) {
			cout << "错误输入" << endl;
			cin.clear();
			cin.ignore(1024, '\n');
			cin >> key;
		}
		system("cls");
		SelectMove();
	}
}oplayer;

void SelectAvailWeapon(const vector<Prop_Weapon>& weapon) {
	int key;
	cout << "选择：";
	cin >> key;
	system("cls");
	if (key == 0) {
		oplayer.ShowGear();
	}
	if (key > 0 && key <= weapon.size()) {
		const Prop_Weapon& selectedWeapon = weapon[key - 1];//输入对应可用武器列表项
		switch (key) {
		case 1:
			oplayer.GearWeapon(selectedWeapon);
			oplayer.ShowGear();
		case 2:
			oplayer.GearWeapon(selectedWeapon);
			oplayer.ShowGear();
		case 3:
			oplayer.GearWeapon(selectedWeapon);
			oplayer.ShowGear();
		case 4:
			oplayer.GearWeapon(selectedWeapon);
			oplayer.ShowGear();
		case 5:
			oplayer.GearWeapon(selectedWeapon);
			oplayer.ShowGear();
		//可用武器case数为可选择数，有需要再加
		default:
			AvailWeapon();
			break;
		}
	}
	else {
		std::cout << "Invalid choice!" << std::endl;
		oplayer.ShowGear();
	}
}

class monster {
public:
	string NAME;
	int HP;
	int DEF;
	int ATK;
	int HPmax;
	int Exp;
	int Coin;
	friend player;
	void setProperty(string mn,int mh = 0, int md = 0, int ma = 0, int me=0,int mm=0) {
		NAME = mn;
		HP = mh;
		DEF = md;
		ATK = ma;
		HPmax = mh;
		Exp = me;
		Coin = mm;
	}
	void mAttack(monster m) {
		if (oplayer.HP - m.ATK + oplayer.DEF >= oplayer.HP) {
			oplayer.HP = oplayer.HP - 1;
			cout << "并造成了 1 点伤害！" << endl;
		}
		else {
			oplayer.HP = oplayer.HP - m.ATK + oplayer.DEF;
			cout << "并造成了 "<< m.ATK - oplayer.DEF<<" 点伤害！" << endl;
		}
	}
}Slime,Goblin, Elite_Goblin,Strong_Goblin;
void UseProp(monster& m);

void setMonster() {//HP,DEF,ATK,Exp,Coin//
	Slime.setProperty("史莱姆", 4, 0, 1, 2, 1);
	Goblin.setProperty("哥布林",7, 0, 3, 4, 3);
	Elite_Goblin.setProperty("哥布林精英", 13, 1, 4, 10, 7);
	Strong_Goblin.setProperty("沉淀哥布林", 10, 0, 4, 6, 4);
}

class Location_Wild {
public:
	monster LWm1, LWm2, LWm3;
	int TreasureCoin;
	void setLocation_Wild(monster m1,monster m2,monster m3,int tc) {
		LWm1 = m1;
		LWm2 = m2;
		LWm3 = m3;
		TreasureCoin = tc;
	}
}LW001,LW002;

void SetLocation_Wild() {//地点：野外探索参数设置
	LW001.setLocation_Wild(Slime, Goblin, Elite_Goblin, 1);
	LW002.setLocation_Wild(Slime, Strong_Goblin, Elite_Goblin, 2);
}
class Prop_Potion {
public:
	string NAME;
	int n;
	int Eff;
	int cost;
	void setProperty(string ppn,int pn,int peff,int pcost) {
		NAME = ppn;
		n = pn;
		Eff = peff;
		cost = pcost;

	}
	void ShowAvailProp_Potion()const {
		cout << NAME << " 数量 " << n << endl;
	}
	void reduce_n() {
		--n;
	}
}chpp,shpp;
void PPsetProperty() {//n,Eff,Cost//
	chpp.setProperty("粗制生命药水", 0, 4, 5);
	shpp.setProperty("制式生命药水", 0, 9, 10);
}
void AvailProp_Potion() {//道具：药水可用
	vector<Prop_Potion> potion = {
		chpp,shpp
	};
	vector<Prop_Potion> filterPotion;
	std::copy_if(potion.begin(), potion.end(), std::back_inserter(filterPotion),
		[](const Prop_Potion& w) { return w.n >= 1; });
	int i = 1;
	for (const auto& potion : filterPotion) {
		cout << i++ << ": ";
		potion.ShowAvailProp_Potion();
	}
	//SelectAvailPotion(filterPotion,m);
}

void ShowProp() {
	int key;
	AvailProp_Potion();
	cout << "输入1以返回" << endl;
	cin >> key;
	while (key != 1) {
		cout << "错误输入" << endl;
		cin.clear();
		cin.ignore(1024, '\n');
		cin >> key;
	}
	system("cls");
	SelectMove();
}

void startGame() {
	int key;
	cout << "=========================\n"
		<< "Welcome to WordsHeim!\n"
		<< "-------------------------" << endl;
	random_device rd;
	mt19937 gen(rd());
	oplayer.InitProperty();
	SetWeapon();
	setMonster();
	PPsetProperty();
	SetLocation_Wild();
	Sleep(2000);
	cout << "1:继续游戏" << setw(15) << "2:新的游戏"
		<< "\n=========================" << endl;
	cin >> key;
	system("cls");
	switch (key) {
	case(1):
		LoadGame();
		oplayer.setProperty();
		oplayer.HP = oplayer.HPmax;
		Sleep(2000);
		break;
	case(2):
		cout << "你的等级为<1>" << endl;
		oplayer.HP = oplayer.HPmax;
		Sleep(2000);
		lplayer.setLocation(克里斯镇);
		Sleep(2000);
		break;
	default:
		cout << "无效输入，请重新选择！\n" << endl;
		cin.clear();
		cin.ignore(1024, '\n');
		startGame();
	}
}

map<Location, vector<Location>> locationConnections = {//地点：关系
	{克里斯镇,{克里斯镇北郊,克里斯镇东郊}},
	{克里斯镇北郊,{克里斯镇}},
	{克里斯镇东郊,{克里斯镇}},
};
string locationName(Location loc) {//地点：枚举数字转字符串
	switch (loc) {
	case 克里斯镇:
		return "克里斯镇";
	case 克里斯镇北郊:
		return "克里斯镇北郊";
	case 克里斯镇东郊:
		return "克里斯镇东郊";
		// ...
	default:
		return "未知地点";
	}
}
void ShowLocation(LOC& loc) {
	Location currentLocation = loc.getLocation();
	std::cout << "当前地点：" << locationName(currentLocation) << std::endl;
}
void SelectMove_Fight(monster& m) {
	int SMF_key = 0;
	cout << "选择行动：" << endl;
	cout << "1:攻击" << endl;
	cout << "2:逃跑" << endl;
	cout << "3:使用道具" << endl;
	cin >> SMF_key;
	system("cls");
	switch (SMF_key) {
	case(1):
		if (m.HP - oplayer.ATK - oplayer.hold.wATK + m.DEF >= m.HP) {
			m.HP = m.HP - 1;
			cout << "你 攻击了 "<<m.NAME<<" 并造成了 1 点伤害！" << endl;
		}
		else {
			m.HP = m.HP - oplayer.ATK - oplayer.hold.wATK + m.DEF;
			cout << "你 攻击了 " << m.NAME << " 造成了 " << oplayer.ATK +oplayer.hold.wATK- m.DEF
				<< " 点伤害!" << endl;
		}break;
	case(2):
		cout << "逃跑成功了！" << endl;
		SelectMove_Wild();
		break;
	case(3):
		UseProp(m);
		SelectMove_Fight(m);
		break;
	default:
		cout << "无效输入，请重新选择！\n" << endl;
		cin.clear();
		cin.ignore(1024, '\n');
		SelectMove_Fight(m);
	}
}
void UseProp(monster& m) {
	vector<Prop_Potion> potion = {
		chpp,shpp
	};
	vector<Prop_Potion> filterPotion;
	std::copy_if(potion.begin(), potion.end(), std::back_inserter(filterPotion),
		[](const Prop_Potion& w) { return w.n >= 1; });
	cout << "你拥有：" << endl;
	AvailProp_Potion();
	cout << "0 返回" << endl;
	int key;
	//cout << potion.size() << endl; 用于debug
	cout << "选择：";
	cin >> key;
	system("cls");
	if (key == 0 ||key>filterPotion.size()|| filterPotion.size() == 0) {
		return;
	}
	Prop_Potion& selectedPotion = filterPotion[key - 1];//输入对应可用药水列表项
	//cout << selectedPotion.NAME << endl; 用于debug
	if (key > 0 && key <= filterPotion.size()) {
		switch (key) {
		case 1:
			cout << "你使用了 " << selectedPotion.NAME << " !" << endl;
			if (oplayer.HPmax - oplayer.HP < selectedPotion.Eff) {
				oplayer.HP = oplayer.HPmax;
				if (selectedPotion.NAME == chpp.NAME) {
					--chpp.n;
					--selectedPotion.n;
				}
				if (selectedPotion.NAME == shpp.NAME) {
					--shpp.n;
					--selectedPotion.n;
				}
				cout << "你的剩余血量：" << oplayer.HP << '\n' << endl;
			}
			else {
				oplayer.HP = oplayer.HP + selectedPotion.Eff;
				if (selectedPotion.NAME == chpp.NAME) {
					--chpp.n;
					--selectedPotion.n;
				}
				if (selectedPotion.NAME == shpp.NAME) {
					--shpp.n;
					--selectedPotion.n;
				}
				cout << "你的剩余血量：" << oplayer.HP << '\n' << endl;
			}
			return;
			break;
		case 2:
			cout << "你使用了 " << selectedPotion.NAME << " !" << endl;
			if (oplayer.HPmax - oplayer.HP < selectedPotion.Eff) {
				oplayer.HP = oplayer.HPmax;
				if (selectedPotion.NAME == chpp.NAME) {
					--chpp.n;
				}
				if (selectedPotion.NAME == shpp.NAME) {
					--shpp.n;
				}
				cout << "你的剩余血量：" << oplayer.HP << '\n' << endl;
			}
			else {
				oplayer.HP = oplayer.HP + selectedPotion.Eff;
				if (selectedPotion.NAME == chpp.NAME) {
					--chpp.n;
				}
				if (selectedPotion.NAME == shpp.NAME) {
					--shpp.n;
				}
				cout << "你的剩余血量：" << oplayer.HP << '\n' << endl;
			}
			return;
			break;
			//可用药水case数为可选择数，增加药水时增加。
		default:
			cout << "错误输入\n" << endl;
			return;
			break;
		}
	}
	else {
		std::cout << "无效输入!" << std::endl;
		return;
	}
}
void ShowProperty_F(monster m) {
	if (oplayer.HP < 0) {
		oplayer.HP = 0;
	}
	cout << "你的剩余血量：" << oplayer.HP << endl;
	if (m.HP < 0) {
		m.HP = 0;
	}
	Sleep(600);
	cout << m.NAME << " 的剩余血量：" << m.HP <<'\n' << endl;
	Sleep(600);
}
void Fight(monster& m) {
	cout << "发现了 "<<m.NAME<<" ！战斗开始！" << endl;
	cout << "你的剩余血量：" << oplayer.HP << '\n' << endl;
	Sleep(600);
	while (oplayer.HP > 0 && m.HP > 0) {
		SelectMove_Fight(m);
		Sleep(600);
		ShowProperty_F(m);
		if(m.HP<=0){
			cout << "毫无悬念的战斗！金币+"<<m.Coin<<"!经验值+" << m.Exp << "!\n" << endl;
			m.HP = m.HPmax;
			oplayer.Coin=oplayer.Coin + m.Coin;
			oplayer.Exp = oplayer.Exp + m.Exp;
			oplayer.LevelUp();
			Sleep(1200);
			SelectMove_Wild();
		}
		cout << m.NAME << " 攻击了 你！";
		m.mAttack(m);
		Sleep(600);
		ShowProperty_F(m);
		Sleep(1200);
	}
	if (oplayer.HP <= 0) {
		m.HP = m.HPmax;
		cout << "犹豫就会败北！果断就会白给！" << endl;
		lplayer.location = safepoint.location;
		Sleep(2000);
		SelectMove();
	}
}
void Move(LOC& mLOC) {
	Location currentLocation = mLOC.getLocation();
	cout << "当前位置：" << locationName(currentLocation) << endl;
	const std::vector<Location>& connectedLocations = locationConnections[currentLocation];
	cout << "可前往的地点：\n";
	for (size_t i = 0; i < connectedLocations.size(); ++i) {
		std::cout << i + 1 << ": 前往 " << locationName(connectedLocations[i]) << std::endl;
	}
	int key;
	cin >> key;
	system("cls");
	if (key >= 1 && key <= static_cast<int>(connectedLocations.size())) {
		mLOC.setLocation(connectedLocations[key - 1]);
		cout << "从地点 " << locationName(currentLocation) << " 移动到地点 " 
			<< locationName(mLOC.getLocation()) << endl;
		if (mLOC.getLocation() != 克里斯镇) {//地点：安全点
			SelectMove_Wild();
		}
		else { SelectMove(); }
	}
	else {
		cout << "无效的选择，请输入有效的数字"<< endl;
		cin.clear();
		cin.ignore(1024, '\n');
		Move(mLOC);
	}
}

void FindTreasure(Location_Wild lwft) {
	cout << "你找到了宝箱！";
	cout << "Coin + "<<lwft.TreasureCoin<<" ！\n";
	oplayer.Coin = oplayer.Coin + lwft.TreasureCoin;
	SelectMove_Wild();
}

void Explore(double poa,double pob,double poc,Location_Wild lw) {
	std::random_device rd; 
	std::mt19937 gen(rd()); 
	std::uniform_real_distribution<> dis(0.0, 1.0);
	double randomValue = dis(gen);
	if (randomValue < poa) {
		Fight(lw.LWm1);
	}
	else if ((poa< randomValue)&&(randomValue < pob)) {
		Fight(lw.LWm2);
	}
	else if ((pob < randomValue) && (randomValue < poc)) {
		Fight(lw.LWm3);
	}
	else if (poc < randomValue) {
		FindTreasure(lw);
	}
}

void SelectMove_Wild() {
	int key = 0;
	ShowLocation(lplayer);
	Sleep(1500);
	cout << "你的下一步是！" << endl;
	Sleep(1500);
	cout << "1:探索此区域" << endl;
	cout << "2:移动" << endl;
	cin >> key;
	system("cls");
	switch (key) {
	case(1)://地点：野外探索
		if (lplayer.location == 1) { Explore(0.4, 0.75, 0.9, LW001); }
		if (lplayer.location == 2) { Explore(0.4, 0.75, 0.9, LW002); }
	case(2):
		Move(lplayer);	
	default:
		cout << "无效输入，请重新选择！" << endl;
		cin.clear();
		cin.ignore(1024, '\n');
		SelectMove_Wild();
	}
}
void PropShop() {
	int PropShop_key, n;
	cout << "请选择您要购买的商品！" << endl;
	cout << "1：粗制生命药水 "<<chpp.cost<<"coin / 1\n"
		<<"2：制式生命药水 "<<shpp.cost<<"coin / 1\n"
		<<"3:返回" << endl;
	cout << "输入：";
	cin >> PropShop_key;
	system("cls");
	switch (PropShop_key) {
	case(1):
		cout << "请输入购买数量" << endl;
		cin >> n;
		system("cls");
		if (n <= 0) { PropShop(); }
		if (oplayer.Coin < n * chpp.cost) {
			cout << "余额不足！！\n" << endl;
			PropShop();
		}
		else {
			oplayer.Coin = oplayer.Coin - n * chpp.cost;
			chpp.n = chpp.n + n;
			cout << "您已购买 " << n << " 瓶粗制生命药水！\n" <<
				"您的余额为" << oplayer.Coin << " 谢谢光临!\n" << endl;
			PropShop();
		}break;
	case(2):
		cout << "请输入购买数量" << endl;
		cin >> n;
		system("cls");
		if (n <= 0) { PropShop(); }
		if (oplayer.Coin < n * shpp.cost) {
			cout << "余额不足！！\n" << endl;
			PropShop();
		}
		else {
			oplayer.Coin = oplayer.Coin - n * shpp.cost;
			shpp.n = shpp.n + n;
			cout << "您已购买 " << n << " 瓶制式生命药水！\n" <<
				"您的余额为" << oplayer.Coin << " 谢谢光临!\n" << endl;
			PropShop();
		}break;
	case(3):
		Shop();
	default:
		cout << "无效输入，请重新选择！\n" << endl;
		cin.clear();
		cin.ignore(1024, '\n');
		PropShop();
	}
}
void WeaponShop() {
	int key, n;
	cout << "请选择您要购买的商品！" << endl;
	cout << "1：" <<w0001.NAME<<" " << w0001.cost << "coin / 1\n"
		<< "2:返回" << endl;
	cout << "输入：";
	cin >> key;
	system("cls");
	switch (key) {
	case(1):
		cout << "请输入购买数量" << endl;
		cin >> n;
		system("cls");
		if (n <= 0) { WeaponShop(); }
		if (oplayer.Coin < n * w0001.cost) {
			cout << "余额不足！！\n" << endl;
			WeaponShop();
		}
		else {
			oplayer.Coin = oplayer.Coin - n * w0001.cost;
			w0001.n = w0001.n + n;
			cout << "您已购买 " << n << " 个 "<<w0001.NAME<<"！\n" <<
				"您的余额为" << oplayer.Coin << " 谢谢光临!\n" << endl;
			WeaponShop();
		}break;
	case(2): {
		Shop();
	}
	case(3):
		Shop();
	default:
		cout << "无效输入，请重新选择！\n" << endl;
		cin.clear();
		cin.ignore(1024, '\n');
		WeaponShop();
	}
}
void Shop() {
	int Shop_key_1;
	cout << "你来到了商业街！" << endl;
	cout << "1:道具店\n2:武器铺\n3:防具铺（未开放）\n4:返回" << endl;
	cin >> Shop_key_1;
	system("cls");
	switch (Shop_key_1) {
	case(1):
		PropShop();
		break;
	case(2):
		WeaponShop();
	case(4):
		SelectMove();
	default:
		cout << "无效输入，请重新选择！\n" << endl;
		cin.clear();
		cin.ignore(1024, '\n');
		Shop();
	}
}
void SelectMove() {
	enum key {l,q,w,e,a,s,d,f,z,x};
	string key2;
	std::map<std::string, key> KeyMap = {
	{"q", key::q},
	{"w", key::w},
	{"e", key::e},
	{"a", key::a},
	{"s", key::s},
	{"d", key::d},
	{"f", key::f},
	{"z", key::z},
	{"x", key::x},
	};
	ShowLocation(lplayer);
	safepoint.setLocation(safepoint.getLocation());
	Sleep(500);
	cout << "\n=========================" << endl;
	cout << "选择下一步行动吧~" << endl;
	cout << "-------------------------" << endl;
	Sleep(600);
	cout << "行动：" << endl;
	cout << left << setw(15) << "q:移动" << left << setw(15) << "w:商业街"
		<< left << setw(15) << "\ne:在旅店休息" << endl;
	cout << "-------------------------" << endl;
	cout << "状态：" << endl;
	cout << left << setw(15) << "a:属性" << left << setw(15) << "s:装备" << endl;
	cout << left << setw(15) << "d:背包" << left << setw(15) << "f:钱包" << endl;
	cout << "-------------------------" << endl;
	cout << "游戏：" << endl;
	cout << setw(15) << "z:保存游戏" << setw(15) << "x:退出游戏" << endl;
	cout << "=========================" << endl;
	cin >> key2;
	auto it = KeyMap.find(key2);
	key key1 = it->second;
	system("cls");
	switch (key1) {
	case(1):
		Move(lplayer);
	case(2):
		Shop();
	case(3):
		oplayer.HP = oplayer.HPmax;
		cout << "睡饱后你的内心充满了斗志。" << endl;
		Sleep(3000);
		system("cls");
		SelectMove();
	case(4):
		oplayer.ShowProperty();
	case(5):
		oplayer.ShowGear();
	case(6):
		ShowProp();
	case(7):
		oplayer.ShowCoin();
	case(8):
		Save();
		Sleep(2000);
		SelectMove();
	case(9):
		exit(0);
		break;
	default:
		cout << "无效输入，请重新选择！\n" << endl;
		cin.clear();
		cin.ignore(1024, '\n');
		SelectMove();
	}
}

struct SaveData {//保存：等级、经验、金币、安全点、道具1、道具2....
	int Lev;
	int Exp;
	int Coin;
	int Safepoint;
	int n_p0001;//道具编码0001
	int n_p0002;
	int n_w0001;//武器编码0001
	string serialize() const {
		return to_string(Lev) + "," + to_string(Exp) + "," + to_string(Coin) + ","
			+ to_string(n_p0001) + "," + to_string(n_p0002) + "," + to_string(Safepoint)
			+ "," + to_string(n_w0001);
	}
	bool deserialize(const string& data) {
		istringstream iss(data);
		std::vector<int> values;
		std::string token;
		while (std::getline(iss, token, ',')) {
			try {
				values.push_back(std::stoi(token));
			}
			catch (const std::invalid_argument& e) {
				std::cerr << "反序列化失败，无法转换数据: " << token << std::endl;
				return false;
			}
			catch (const std::out_of_range& e) {
				std::cerr << "反序列化失败，整数超出范围: " << token << std::endl;
				return false;
			}
		}
		values.resize(10,0);//新增内容时增加n
		//values[5] = 0;		//为新内容设置默认值（后兼容）
		oplayer.Lev = values[0];
		oplayer.Exp = values[1];
		oplayer.Coin = values[2];
		n_p0001 = values[3];
		chpp.n = n_p0001;
		n_p0002 = values[4];
		shpp.n = n_p0002;
		safepoint.location = static_cast<Location>(values[5]);
		n_w0001 = values[6];
		w0001.n = n_w0001;
		return true;
	}
};

void saveGame(const SaveData& saveData, const string& filename) {
	ofstream file(filename);
	if (!file.is_open()) {
		cerr << "保存不成功。\n";
		return;
	}
	else { cout << "保存成功！" << endl; }
	file << saveData.serialize();
	file.close();
}
bool loadGame(SaveData& saveData, const string& filename) {
	ifstream file(filename);
	if (!file.is_open()) {
		cerr << "打开加载文件失败。\n";
		return false;
	}
	string line;
	getline(file, line);
	file.close();
	return saveData.deserialize(line);
}

void Save() {//保存
	SaveData save01 = { oplayer.Lev,oplayer.Exp,oplayer.Coin,safepoint.location,
		chpp.n,shpp.n,w0001.n };
	saveGame(save01, "save01.txt");
}
void LoadGame() {
	SaveData loadedSave;
	if (loadGame(loadedSave, "save01.txt")) {
		cout << "游戏加载成功！\n";
	}
	else {
		cout << "游戏加载失败！\n";
	}
}
int main() {
	startGame();
	SelectMove();
	return 0;
}
